<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Swipe (เสียงล้วน)</title>
<style>
  html,body { height:100%; margin:0; background:#000; }
  /* หน้าเริ่มมีปุ่มเดียว */
  #startScreen {
    display:flex; align-items:center; justify-content:center; height:100%;
  }
  #startBtn {
    font-size:24px; padding:18px 30px; border-radius:12px;
    background:#1e88e5; color:#fff; border:none;
  }
  /* พื้นที่เกมเต็มจอ (ไม่มีข้อความ) */
  #gameArea {
    display:none; position:fixed; inset:0; background:#000;
    touch-action: none; /* ให้เราควบคุม gesture */
  }
  /* สถานะซ่อน (สำหรับ debug ถ้าต้องการ เปิดให้เห็น) */
  #hiddenDebug { position:fixed; left:-9999px; top:-9999px; }
</style>
</head>
<body>

<!-- Start screen -->
<div id="startScreen" aria-hidden="false">
  <button id="startBtn">Start</button>
</div>

<!-- Game area: ไม่มีข้อความแสดง -->
<div id="gameArea" aria-hidden="true"></div>

<!-- Hidden debug (ไม่แสดง) -->
<div id="hiddenDebug" aria-hidden="true"></div>

<!-- Audio elements (ต้องมีไฟล์ในโฟลเดอร์เดียวกัน) -->
<audio id="audio_start" src="start.mp3" preload="auto"></audio>
<audio id="audio_bg" src="background.mp3" preload="auto" loop></audio>

<audio id="a_left" src="left.mp3" preload="auto"></audio>
<audio id="a_right" src="right.mp3" preload="auto"></audio>
<audio id="a_up" src="up.mp3" preload="auto"></audio>
<audio id="a_down" src="down.mp3" preload="auto"></audio>
<audio id="a_touch" src="touch.mp3" preload="auto"></audio>
<audio id="a_touch2" src="touch2.mp3" preload="auto"></audio>

<audio id="a_win" src="win.mp3" preload="auto"></audio>
<audio id="a_lost" src="lost.mp3" preload="auto"></audio>
<audio id="a_endlost" src="endlost.mp3" preload="auto"></audio>
<audio id="a_endhappy" src="endhappy.mp3" preload="auto"></audio>

<script>
(() => {
  // Gestures list and mapping to audio elements
  const GESTURES = ['left','right','up','down','tap','doubletap'];
  const gestureAudio = {
    left: document.getElementById('a_left'),
    right: document.getElementById('a_right'),
    up: document.getElementById('a_up'),
    down: document.getElementById('a_down'),
    tap: document.getElementById('a_touch'),
    doubletap: document.getElementById('a_touch2'),
  };
  const audio_start = document.getElementById('audio_start');
  const audio_bg = document.getElementById('audio_bg');
  const audio_win = document.getElementById('a_win');
  const audio_lost = document.getElementById('a_lost');
  const audio_endlost = document.getElementById('a_endlost');
  const audio_endhappy = document.getElementById('a_endhappy');

  const startBtn = document.getElementById('startBtn');
  const startScreen = document.getElementById('startScreen');
  const gameArea = document.getElementById('gameArea');

  let gameState = {
    running: false,
    roundIndex: 1,          // starts at 1
    mistakes: 0,
    sequence: [],           // current sequence of gesture strings
    seqPos: 0,              // next expected index
    roundTimer: null,
    roundTimeoutMs: 0,
    coachPlaying: false,
    awaitingRestartSwipe: false,
    listenInputs: false,
    waitingForRoundGap: false,
  };

  // ---------- Helper: compute gestures-per-round and allowed time ----------
  function roundConfigFor(roundIndex) {
    // Each block of 3 rounds increases gesture count by 1, starting at 1 for rounds 1-3
    // Times based on pattern described; extrapolated up to 10 gestures
    const block = Math.floor((roundIndex - 1) / 3); // 0 => rounds 1-3
    const gestures = 1 + block; // 1,2,3,... up to 10
    // time logic: block 0 and 1 => 2.0s (for block 0); block1 remains 2.0; from block2 onwards +0.5 each block
    let timeSeconds;
    if (block <= 1) timeSeconds = 2.0;
    else timeSeconds = 2.0 + 0.5 * (block - 1);
    // clamp gestures to max 10
    return { gestures: Math.min(gestures, 10), timeSeconds };
  }

  // ---------- Random sequence generator ----------
  function makeSequence(length) {
    const seq = [];
    for (let i=0;i<length;i++){
      const g = GESTURES[Math.floor(Math.random()*GESTURES.length)];
      seq.push(g);
    }
    return seq;
  }

  // ---------- Play a gesture audio (returns Promise resolved when ended) ----------
  function playGestureAudio(name) {
    return new Promise((resolve) => {
      const aud = gestureAudio[name];
      if(!aud) return resolve();
      aud.currentTime = 0;
      aud.play().catch(()=>{/*ignore*/});
      const onEnd = () => { aud.removeEventListener('ended', onEnd); resolve(); };
      aud.addEventListener('ended', onEnd);
    });
  }

  // ---------- Play list of coach audios in sequence, but allow user to input anytime ----------
  async function playCoachSequence(seq) {
    gameState.coachPlaying = true;
    for (let i=0;i<seq.length;i++){
      const g = seq[i];
      // Play audio for this prompt
      await playGestureAudio(g);
      // small gap so player can react (but they can react anytime)
      await new Promise(r => setTimeout(r, 120));
      if (!gameState.running) break;
    }
    gameState.coachPlaying = false;
  }

  // ---------- Round handling ----------
  function startRound() {
    if (!gameState.running) return;
    const cfg = roundConfigFor(gameState.roundIndex);
    gameState.sequence = makeSequence(cfg.gestures);
    gameState.seqPos = 0;
    gameState.roundTimeoutMs = Math.round(cfg.timeSeconds * 1000);
    // Start round: play coach prompts but we start the timer when first prompt starts
    // Start a timer that will fail the round if time runs out before sequence complete
    // We will start the timer just before playing first audio
    // BUT we must ensure 3-second delay before first round only (handled externally)
    // Play coach prompts (user can input anytime)
    // Start the timer now (we'll allow player to act while prompts playing)
    clearRoundTimer();
    gameState.roundTimer = setTimeout(() => {
      // time up: treat as mistake (round lost)
      if (!gameState.running) return;
      handleRoundFail('timeout');
    }, gameState.roundTimeoutMs);

    // Play prompts asynchronously (no await here)
    playCoachSequence(gameState.sequence);
  }

  function clearRoundTimer() {
    if (gameState.roundTimer) {
      clearTimeout(gameState.roundTimer);
      gameState.roundTimer = null;
    }
  }

  async function handleRoundSuccess() {
    clearRoundTimer();
    // play win.mp3 fully
    try {
      audio_win.currentTime = 0;
      await audio_win.play().catch(()=>{});
      await new Promise((res) => {
        audio_win.addEventListener('ended', function w(){ audio_win.removeEventListener('ended', w); res(); });
      });
    } catch(e){}
    // check victory condition: if the sequence length is 10 OR gestures required equals 10 -> game won
    const cfg = roundConfigFor(gameState.roundIndex);
    if (cfg.gestures >= 10) {
      // end happy
      audio_bg.pause(); audio_bg.currentTime = 0;
      try {
        audio_endhappy.currentTime = 0;
        await audio_endhappy.play().catch(()=>{});
        await new Promise((res)=>{ audio_endhappy.addEventListener('ended', function h(){ audio_endhappy.removeEventListener('ended', h); res(); }); });
      } catch(e){}
      resetToAwaitRestart();
      return;
    }
    // else wait 1s then next round
    await new Promise(r => setTimeout(r, 1000));
    nextRound();
  }

  async function handleRoundFail(reason) {
    clearRoundTimer();
    gameState.mistakes++;
    // play lost.mp3 fully
    try {
      audio_lost.currentTime = 0;
      await audio_lost.play().catch(()=>{});
      await new Promise((res)=>{ audio_lost.addEventListener('ended', function l(){ audio_lost.removeEventListener('ended', l); res(); }); });
    } catch(e){}
    if (gameState.mistakes >= 3) {
      // final lose
      audio_bg.pause(); audio_bg.currentTime = 0;
      try {
        audio_endlost.currentTime = 0;
        await audio_endlost.play().catch(()=>{});
        await new Promise((res)=>{ audio_endlost.addEventListener('ended', function e(){ audio_endlost.removeEventListener('ended', e); res(); }); });
      } catch(e){}
      resetToAwaitRestart();
      return;
    }
    // else wait 1s then next round
    await new Promise(r => setTimeout(r, 1000));
    nextRound();
  }

  function nextRound() {
    gameState.roundIndex++;
    startRound();
  }

  function resetToAwaitRestart() {
    // Stop everything and wait for 2-finger swipe up to restart (as requested)
    gameState.running = false;
    gameState.awaitingRestartSwipe = true;
    gameState.sequence = [];
    gameState.seqPos = 0;
    gameState.roundIndex = 1;
    gameState.mistakes = 0;
    clearRoundTimer();
    // show gameArea (still visible but listening for restart swipe)
  }

  // ---------- Input matching ----------
  function consumeGesture(g) {
    if (!gameState.running) {
      // if awaiting restart and gesture is two-finger-swipe-up, handled elsewhere
      return;
    }
    if (!gameState.listenInputs) {
      // allow inputs anytime during round; but only accept if a round is active (we check running)
    }
    // Compare g with expected
    const expected = gameState.sequence[gameState.seqPos];
    if (expected === g) {
      gameState.seqPos++;
      // If completed sequence
      if (gameState.seqPos >= gameState.sequence.length) {
        handleRoundSuccess();
      }
    } else {
      handleRoundFail('wrong');
    }
  }

  // ---------- Gesture detection ----------
  // We'll detect: swipe left/right/up/down (single-finger)
  // tap (single touch quick), doubletap
  // two-finger swipe up to START/RESTART the game (when in gameArea)
  let touchState = {
    startTouches: null,
    startTime: 0,
    lastTapTime: 0,
    lastTapPos: null,
    tapTimeout: null,
  };

  function resetTouchState() {
    touchState.startTouches = null;
    touchState.startTime = 0;
  }

  gameArea.addEventListener('touchstart', function(e){
    e.preventDefault();
    touchState.startTime = Date.now();
    // record touches positions
    touchState.startTouches = [];
    for (let i=0;i<e.touches.length;i++){
      touchState.startTouches.push({x:e.touches[i].clientX, y:e.touches[i].clientY, id: e.touches[i].identifier});
    }
  }, {passive:false});

  gameArea.addEventListener('touchend', function(e){
    e.preventDefault();
    const now = Date.now();
    const duration = now - touchState.startTime;
    // get end touches from changedTouches if any, else use last known positions
    const changed = e.changedTouches;
    // If there were 2 or more start touches and overall movement is up enough => two-finger swipe up
    if (touchState.startTouches && touchState.startTouches.length >= 2) {
      // try to find end positions of those touches in changedTouches; if changedTouches fewer, use start positions as fallback
      let allMovedUp = true;
      for (let i=0;i<touchState.startTouches.length;i++){
        const s = touchState.startTouches[i];
        // find matching changed touch by id
        let found = null;
        for (let j=0;j<changed.length;j++){
          if (changed[j].identifier === s.id) { found = changed[j]; break; }
        }
        const endY = found ? found.clientY : s.y - 50; // assume moved up if not found
        const dy = endY - s.y;
        if (dy > -30) allMovedUp = false; // not moved enough up
      }
      if (allMovedUp && touchState.startTouches.length >= 2) {
        // two-finger swipe up detected
        // If game not running, use for start/restart
        if (!gameState.running) {
          startGameFromTwoFingerSwipe();
        } else {
          // If game is running and they used two-finger swipe up: treat as 'up' gesture? We'll ignore multi-finger gestures during running for player inputs.
        }
        resetTouchState();
        return;
      }
    }

    // If single touch occurred (or first finger), attempt to detect swipe or tap
    // Try to get primary start and end pos
    const start = touchState.startTouches && touchState.startTouches[0];
    const endTouch = changed[0];
    if (!start || !endTouch) {
      resetTouchState();
      return;
    }
    const dx = endTouch.clientX - start.x;
    const dy = endTouch.clientY - start.y;
    const dist = Math.hypot(dx,dy);
    const isTap = (dist < 20 && duration < 300);
    if (isTap) {
      // handle double-tap detection
      if (touchState.lastTapTime && (now - touchState.lastTapTime) < 350) {
        // double tap
        touchState.lastTapTime = 0;
        consumeGesture('doubletap');
      } else {
        touchState.lastTapTime = now;
        // schedule single tap if no second tap
        if (touchState.tapTimeout) clearTimeout(touchState.tapTimeout);
        touchState.tapTimeout = setTimeout(() => {
          consumeGesture('tap');
          touchState.tapTimeout = null;
        }, 360);
      }
    } else if (dist >= 30) {
      // swipe detection - determine direction
      if (Math.abs(dx) > Math.abs(dy)) {
        // horizontal
        if (dx > 0) consumeGesture('right'); else consumeGesture('left');
      } else {
        // vertical
        if (dy > 0) consumeGesture('down'); else consumeGesture('up');
      }
    }
    resetTouchState();
  }, {passive:false});

  // ---------- Start / Restart logic ----------
  startBtn.addEventListener('click', function(){
    // Play start.mp3. After it ends, hide start screen and reveal game area waiting for 2-finger swipe up to begin.
    audio_start.currentTime = 0;
    audio_start.play().catch(()=>{});
    audio_start.addEventListener('ended', function onS(){
      audio_start.removeEventListener('ended', onS);
      // hide start screen
      startScreen.style.display = 'none';
      gameArea.style.display = 'block';
      gameArea.focus && gameArea.focus();
      gameState.awaitingRestartSwipe = true; // wait for 2-finger swipe up to actually start
    });
  });

  function startGameFromTwoFingerSwipe() {
    // start actual game: play background.mp3 loop, set running true, delay 3s before first round
    if (gameState.running) return; // already running
    audio_bg.currentTime = 0;
    audio_bg.play().catch(()=>{});
    gameState.running = true;
    gameState.awaitingRestartSwipe = false;
    gameState.roundIndex = 1;
    gameState.mistakes = 0;
    gameState.seqPos = 0;
    gameState.sequence = [];
    // 3-second initial delay before round 1 coach prompts
    setTimeout(() => {
      startRound();
    }, 3000);
  }

  // ---------- For safety: stop background when page hidden/unload ----------
  window.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      audio_bg.pause();
    }
  });
  window.addEventListener('pagehide', ()=>{ audio_bg.pause(); });

  // ---------- For debugging (hidden) ----------
  function debugLog(t){ const d = document.getElementById('hiddenDebug'); d.textContent = t; }

  // Expose consumeGesture for internal testing
  window._consumeGesture = consumeGesture;

  // Also allow keyboard keys for quick local testing (optional)
  window.addEventListener('keydown', (e)=>{
    // For developer testing on desktop:
    const map = { ArrowLeft:'left', ArrowRight:'right', ArrowUp:'up', ArrowDown:'down', 't':'tap', 'd':'doubletap' };
    if (map[e.key]) consumeGesture(map[e.key]);
    if (e.key === 'S') {
      // simulate two-finger swipe up start
      startGameFromTwoFingerSwipe();
    }
  });

})();
</script>
</body>
</html>
