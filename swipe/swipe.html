<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Swipe — เกมปัดและแตะ</title>
<style>
  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;}
  body{background:#111;color:#fff;display:flex;align-items:center;justify-content:center;}
  #container{width:100%;height:100%;position:relative;overflow:hidden;}
  /* พื้นที่เกมขนาดเต็มจอ */
  #gameArea{position:absolute;inset:0;background:linear-gradient(180deg,#0b1220,#081b2a);display:flex;align-items:center;justify-content:center;touch-action:none;}
  #startPanel{position:absolute;z-index:20;display:flex;flex-direction:column;gap:12px;align-items:center;justify-content:center;}
  button{padding:14px 24px;border-radius:12px;border:0;background:#1e90ff;color:white;font-size:18px;box-shadow:0 6px 18px rgba(0,0,0,.4);}
  button:active{transform:translateY(1px);}
  /* small status (hidden visually but helpful for debugging) */
  #status{position:absolute;left:12px;top:12px;z-index:50;font-size:13px;opacity:0.9;color:#ddd;}
  /* hint เล็กๆ สำหรับผู้ใช้ (ตอนสตาร์ท) */
  #hint{position:absolute;bottom:18px;left:50%;transform:translateX(-50%);font-size:13px;color:#cfd8dc;opacity:0.9}
  /* แสดงวงกลมตอบรับการแตะ/ปัด (แค่ให้มี feedback เล็กๆ) */
  .feedback{position:absolute;border-radius:50%;width:90px;height:90px;transform:translate(-50%,-50%);opacity:0.14;background:linear-gradient(45deg,#fff,#89f);}
</style>
</head>
<body>
  <div id="container">
    <div id="gameArea" aria-hidden="false"></div>

    <div id="startPanel">
      <button id="startBtn" aria-label="Start game">Start</button>
      <div id="hint">หลังจากฟังเสียงเริ่ม — ใช้ 2 นิ้วปัดขึ้นเพื่อเริ่มเล่น</div>
    </div>

    <div id="status" aria-hidden="true">ready</div>
  </div>

<script>
/*
  Swipe Game — implementation (Thai comments)
  - วางไฟล์เสียงในโฟลเดอร์เดียวกันกับไฟล์นี้:
    start.mp3, background.mp3,
    left.mp3, right.mp3, up.mp3, down.mp3, touch.mp3, touch2.mp3,
    win.mp3, lost.mp3, endlost.mp3, endhappy.mp3
*/

// --- การตั้งค่าและ resource audio ---
const SOUNDS = {
  start: new Audio('start.mp3'),
  background: new Audio('background.mp3'),
  left: new Audio('left.mp3'),
  right: new Audio('right.mp3'),
  up: new Audio('up.mp3'),
  down: new Audio('down.mp3'),
  touch: new Audio('touch.mp3'),
  touch2: new Audio('touch2.mp3'),
  win: new Audio('win.mp3'),
  lost: new Audio('lost.mp3'),
  endlost: new Audio('endlost.mp3'),
  endhappy: new Audio('endhappy.mp3'),
};

// ensure background loops
SOUNDS.background.loop = true;

// map gesture keys to sound objects and readable keys
const GESTURES = [
  { key: 'left', audio: SOUNDS.left },
  { key: 'right', audio: SOUNDS.right },
  { key: 'up', audio: SOUNDS.up },
  { key: 'down', audio: SOUNDS.down },
  { key: 'touch', audio: SOUNDS.touch },
  { key: 'touch2', audio: SOUNDS.touch2 }
];

const gameArea = document.getElementById('gameArea');
const startBtn = document.getElementById('startBtn');
const startPanel = document.getElementById('startPanel');
const statusEl = document.getElementById('status');

// state
let gameState = {
  running: false,
  round: 0,
  mistakes: 0,
  expectedSeq: [],
  playerIndex: 0,
  roundTimer: null,
  allowInput: false,
  bgPlaying: false,
};

// helper — log small status
function setStatus(s){
  statusEl.textContent = s;
}

// --- รอบและเวลา (ขยายจนถึง 10 ท่า) ---
// กฎต้นฉบับ: r1-3 =>1ท่า (2s), r4-6=>2ท่า (2s), r7-9=>3ท่า(2.5s), r10-12=>4(3s),
// r13-15=>5(3.5s), r16-18=>6(4s)
// ขยาย: r19-21=>7(4.5s), r22-24=>8(5s), r25-27=>9(5.5s), r28-30=>10(6s)
function getRoundConfig(roundNum){
  // roundNum is 1-based
  if(roundNum <= 3) return { gestures:1, time:2000 };
  if(roundNum <= 6) return { gestures:2, time:2000 };
  if(roundNum <= 9) return { gestures:3, time:2500 };
  if(roundNum <= 12) return { gestures:4, time:3000 };
  if(roundNum <= 15) return { gestures:5, time:3500 };
  if(roundNum <= 18) return { gestures:6, time:4000 };
  if(roundNum <= 21) return { gestures:7, time:4500 };
  if(roundNum <= 24) return { gestures:8, time:5000 };
  if(roundNum <= 27) return { gestures:9, time:5500 };
  // up to 30
  return { gestures:10, time:6000 };
}

// --- สุ่มชุดคำสั่ง (sequence) ---
function randomSequence(n){
  const seq = [];
  for(let i=0;i<n;i++){
    const idx = Math.floor(Math.random()*GESTURES.length);
    seq.push(GESTURES[idx].key);
  }
  return seq;
}

// --- เล่นชุดเสียงโจทย์ทีละไฟล์ (เรียงกัน) ---
async function playSequenceAudio(seq){
  // เล่นเรียงกันและรอให้แต่ละไฟล์จบก่อน (ใช้ promise)
  for(const key of seq){
    const g = GESTURES.find(x=>x.key===key);
    if(!g) continue;
    await playAudioAndWait(g.audio);
    // เว้นว่างสั้นๆ ระหว่างคำสั่ง
    await delay(250);
  }
}

// helper play audio and wait finish (returns Promise)
function playAudioAndWait(audio){
  return new Promise((resolve) => {
    // clone to avoid interrupting same object if played elsewhere
    const a = audio.cloneNode();
    a.play().catch(()=>{/* ignore */});
    a.addEventListener('ended', ()=> resolve(), { once:true });
    // safety: if error or not supported, resolve after 2s
    a.addEventListener('error', ()=> setTimeout(resolve,2000), { once:true });
  });
}

function delay(ms){
  return new Promise(resolve => setTimeout(resolve, ms));
}

// --- จัดการเริ่มต้นเกม ---
startBtn.addEventListener('click', async ()=>{
  // บทบาท: play start.mp3, เมื่อจบแล้ว user ต้องใช้ 2 นิ้วปัดขึ้นเพื่อเริ่มจริง
  setStatus('playing start');
  startBtn.disabled = true;
  SOUNDS.start.play().catch(()=>{});
  await new Promise(resolve => {
    SOUNDS.start.addEventListener('ended', ()=> resolve(), { once:true });
    SOUNDS.start.addEventListener('error', ()=> setTimeout(resolve, 500), { once:true });
  });
  setStatus('waiting for 2-finger swipe up to begin');
  // ซ่อนปุ่มแต่นำไว้เพื่อให้ผู้ใช้สามารถกดอีกครั้งถ้าต้องการ
  startPanel.style.display = 'none';
  // แสดงพื้นที่เกมเต็มจอ (already visible)
});

// --- ถ้าอยากให้ Start panel กลับมาเมื่อเกมจบ สามารถเรียก showStartPanel() ---
function showStartPanel(){
  startBtn.disabled = false;
  startPanel.style.display = 'flex';
}

// --- background control ---
function startBackground(){
  if(!gameState.bgPlaying){
    SOUNDS.background.currentTime = 0;
    SOUNDS.background.play().catch(()=>{/*ignore*/});
    gameState.bgPlaying = true;
  }
}
function stopBackground(){
  if(gameState.bgPlaying){
    SOUNDS.background.pause();
    SOUNDS.background.currentTime = 0;
    gameState.bgPlaying = false;
  }
}

// --- การเล่นรอบใหม่ ---
async function startNextRound(){
  gameState.round += 1;
  gameState.playerIndex = 0;
  const cfg = getRoundConfig(gameState.round);
  const n = cfg.gestures;
  setStatus(`Round ${gameState.round} — gestures: ${n} time(ms): ${cfg.time}`);
  // สุ่ม sequence
  gameState.expectedSeq = randomSequence(n);
  // หน่วง 3 วินาทีก่อนโจทย์ข้อแรก (ตามสเปค)
  await delay(3000);
  // เล่นไฟล์โจทย์ทีละท่า (audio prompts)
  await playSequenceAudio(gameState.expectedSeq);
  // เปิดให้ผู้เล่นป้อนคำตอบ (รวมเวลาที่กำหนดสำหรับทั้งรอบ)
  gameState.allowInput = true;
  // ตั้ง timeout สำหรับรอบ
  if(gameState.roundTimer) clearTimeout(gameState.roundTimer);
  gameState.roundTimer = setTimeout(()=> {
    // timeout หมายถึงถือว่า "ผิด" รอบนั้นทันที
    if(gameState.allowInput){
      gameState.allowInput = false;
      onPlayerWrong();
    }
  }, cfg.time);
  setStatus(`Input allowed — must complete ${n} gestures`);
}

// --- เมื่อผู้เล่นชนะรอบ (ทำครบถูกต้อง) ---
async function onPlayerWinRound(){
  gameState.allowInput = false;
  if(gameState.roundTimer){ clearTimeout(gameState.roundTimer); gameState.roundTimer = null; }
  setStatus('round win — playing win.mp3');
  await playAudioAndWait(SOUNDS.win);
  // หน่วง 1 วินาทีก่อนเริ่มรอบต่อไป
  await delay(1000);

  // ถ้าผู้เล่นถึงเป้าหมาย 10 gestures ในรอบนั้น (ตามสเปค ถือว่าเก่ง จบเกม)
  const cfg = getRoundConfig(gameState.round);
  if(cfg.gestures >= 10){
    // จบเกมแบบชนะใหญ่
    setStatus('game cleared! playing endhappy');
    stopBackground();
    await playAudioAndWait(SOUNDS.endhappy);
    gameState.running = false;
    showStartPanel();
    return;
  }

  // ถ้ายังไม่จบ ให้ไปรอบถัดไป
  startNextRound().catch(()=>{/*ignore*/});
}

// --- เมื่อผู้เล่นทำผิดรอบนั้นทันที ---
async function onPlayerWrong(){
  gameState.allowInput = false;
  if(gameState.roundTimer){ clearTimeout(gameState.roundTimer); gameState.roundTimer = null; }
  gameState.mistakes += 1;
  setStatus(`wrong! mistakes: ${gameState.mistakes}`);
  await playAudioAndWait(SOUNDS.lost);
  await delay(1000);
  if(gameState.mistakes >= 3){
    // game over lost
    stopBackground();
    await playAudioAndWait(SOUNDS.endlost);
    gameState.running = false;
    showStartPanel();
    return;
  } else {
    // ไปต่อรอบถัดไป (ผู้เล่นยังมีสิทธิ์)
    startNextRound().catch(()=>{/*ignore*/});
  }
}

// --- Gesture detection ---
// Detect: swipe left/right/up/down, tap, double tap
// Also detect two-finger swipe up to start the game (must be two or more touches and dy < -threshold)
let touchState = {
  startTouches: null,
  startTime: 0,
  lastTapTime: 0,
  lastTapPos: null,
};

const SWIPE_THRESHOLD = 40; // px to be considered swipe
const TAP_MAX_MOVE = 25; // px
const TAP_MAX_TIME = 350; // ms for tap
const DOUBLE_TAP_WINDOW = 350; // ms between taps for double tap

gameArea.addEventListener('touchstart', (e)=>{
  // for 2-finger start detection: if startPanel hidden and start played, start game on 2-finger swipe up
  touchState.startTouches = [...e.touches].map(t=>({x:t.clientX,y:t.clientY, id: t.identifier}));
  touchState.startTime = Date.now();
});

gameArea.addEventListener('touchend', async (e)=>{
  const now = Date.now();
  const duration = now - touchState.startTime;
  // get changedTouches? use changedTouches for ended points
  const ended = [...e.changedTouches];
  // if there were at least 2 touches at start and movement upward significant => consider 2-finger swipe up
  if(touchState.startTouches && touchState.startTouches.length >= 2){
    // find average start y
    const startAvgY = touchState.startTouches.reduce((s,t)=>s+t.y,0)/touchState.startTouches.length;
    // compute end positions from ended touches or remaining touches
    // find corresponding touches in changedTouches by id; if not found, fallback to first changed
    let endYs = [];
    for(const st of touchState.startTouches){
      const ch = ended.find(c=>c.identifier===st.id);
      if(ch) endYs.push(ch.clientY);
      else {
        // fallback: use first changed
        endYs.push(ended[0] ? ended[0].clientY : st.y);
      }
    }
    const endAvgY = endYs.reduce((s,y)=>s+y,0)/endYs.length;
    const dy = endAvgY - startAvgY;
    if(dy < -SWIPE_THRESHOLD){
      // two-finger swipe up detected
      // But only start the game if startPanel was hidden (meaning start.mp3 played)
      if(!gameState.running && startPanel.style.display === 'none'){
        // start the actual gameplay
        gameState.running = true;
        gameState.round = 0;
        gameState.mistakes = 0;
        setStatus('two-finger swipe up detected — starting game');
        startBackground();
        // start first round
        await startNextRound();
      } else if(!gameState.running && startPanel.style.display !== 'none'){
        // if start panel still visible, ignore (user didn't press Start)
      } else if(!gameState.running && startPanel.style.display === 'none'){
        // start new game if previously ended and user swipes up
        gameState.running = true;
        gameState.round = 0;
        gameState.mistakes = 0;
        startBackground();
        await startNextRound();
      }
      // clear touchState
      touchState.startTouches = null;
      return;
    }
  }

  // For single/one-finger gestures: determine if it was a swipe or tap/double-tap
  // Use the first changed touch as representative
  const ch = ended[0];
  if(!ch || !touchState.startTouches || touchState.startTouches.length === 0){
    return;
  }
  const start = touchState.startTouches[0];
  const dx = ch.clientX - start.x;
  const dy = ch.clientY - start.y;
  const absdx = Math.abs(dx);
  const absdy = Math.abs(dy);

  // Determine swipe
  let detected = null;
  if(duration <= 1000 && Math.max(absdx,absdy) >= SWIPE_THRESHOLD){
    if(absdx > absdy){
      if(dx > 0) detected = 'right'; else detected = 'left';
    } else {
      if(dy > 0) detected = 'down'; else detected = 'up';
    }
  } else if(Math.max(absdx,absdy) <= TAP_MAX_MOVE && duration <= TAP_MAX_TIME){
    // tap candidate
    const lastTapDiff = now - touchState.lastTapTime;
    if(lastTapDiff <= DOUBLE_TAP_WINDOW && touchState.lastTapPos){
      const ddx = start.x - touchState.lastTapPos.x;
      const ddy = start.y - touchState.lastTapPos.y;
      if(Math.hypot(ddx,ddy) <= TAP_MAX_MOVE){
        detected = 'touch2';
        // reset lastTapTime so triple won't be misdetected
        touchState.lastTapTime = 0;
        touchState.lastTapPos = null;
      } else {
        detected = 'touch';
        touchState.lastTapTime = now;
        touchState.lastTapPos = {x:start.x,y:start.y};
      }
    } else {
      detected = 'touch';
      touchState.lastTapTime = now;
      touchState.lastTapPos = {x:start.x,y:start.y};
    }
  }

  // show tiny visual feedback
  if(detected){
    showFeedback(ch.clientX, ch.clientY);
    // if game currently allowing input, evaluate
    if(gameState.allowInput && gameState.running){
      evaluatePlayerGesture(detected);
    }
  }

  // clear startTouches
  touchState.startTouches = null;
});

// small ripple feedback
function showFeedback(x,y){
  const el = document.createElement('div');
  el.className = 'feedback';
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  document.body.appendChild(el);
  setTimeout(()=> el.style.transition = 'opacity 400ms, transform 400ms', 10);
  setTimeout(()=> { el.style.opacity = '0'; el.style.transform = 'translate(-50%,-50%) scale(1.6)'; }, 40);
  setTimeout(()=> el.remove(), 500);
}

// --- เมื่อผู้เล่นป้อนท่าทาง — ตรวจสอบกับ expectedSeq ---
function evaluatePlayerGesture(detected){
  // detected is one of 'left','right','up','down','touch','touch2'
  const expected = gameState.expectedSeq[gameState.playerIndex];
  // Allow player to perform gestures immediately after hearing any prompt;
  // we compare order strictly — if mismatched => wrong immediately
  if(detected === expected){
    // correct for this index
    gameState.playerIndex += 1;
    setStatus(`correct ${gameState.playerIndex}/${gameState.expectedSeq.length}`);
    // If completed whole sequence
    if(gameState.playerIndex >= gameState.expectedSeq.length){
      onPlayerWinRound().catch(()=>{/*ignore*/});
    }
  } else {
    // wrong
    onPlayerWrong().catch(()=>{/*ignore*/});
  }
}

// --- Pause/resume on visibility change to avoid audio playing in background unintentionally ---
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden){
    // pause all non-background audios to be polite
    Object.values(SOUNDS).forEach(a=>{
      try{ a.pause(); }catch(e){}
    });
    // background may be paused: we will not auto-resume
  } else {
    // nothing automatic
  }
});

// initial status
setStatus('ready');

// Make sure audio can play on user gesture (browsers block autoplay)
window.addEventListener('touchstart', function once(){ 
  // resume audio contexts on first touch if needed (best-effort)
  Object.values(SOUNDS).forEach(a=>{ try{ a.play().then(()=>a.pause()); }catch(e){} });
  window.removeEventListener('touchstart', once);
}, {passive:true});

</script>
</body>
</html>
