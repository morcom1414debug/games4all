<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Swipe (accessible) - Swipe Game</title>
<style>
  /* ไม่มีข้อความแสดงผล - พื้นที่เล่นเต็มจอ */
  html,body{height:100%;margin:0}
  body{background:#111;color:#111;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans',sans-serif}
  #container{height:100vh;display:flex;align-items:center;justify-content:center}
  #startBtn{position:relative;z-index:10;padding:18px 28px;border-radius:12px;background:#222;color:#fff;border:1px solid #444;font-size:18px}
  #gameArea{position:fixed;inset:0;background:#000;display:none;touch-action:none}
  /* มอบพื้นที่ซ่อนข้อความสำหรับผู้ใช้ VoiceOver/ScreenReader */
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
</style>
</head>
<body>
<div id="container">
  <button id="startBtn" aria-label="เริ่มเกม">เริ่ม</button>
</div>
<div id="gameArea" role="application" aria-hidden="false" tabindex="0" aria-label="พื้นที่เกม Swipe"></div>
<!-- ซ่อนข้อความสำหรับ screen reader -->
<div id="sr" class="sr-only" aria-live="assertive"></div>

<!-- เสียงต่าง ๆ (ผู้ใช้ต้องจัดวางไฟล์ mp3 เหล่านี้ในโฟลเดอร์เดียวกัน) -->
<audio id="audioStart" src="start.mp3" preload="auto"></audio>
<audio id="audioBackground" src="background.mp3" preload="auto" loop></audio>
<audio id="a_left" src="left.mp3" preload="auto"></audio>
<audio id="a_right" src="right.mp3" preload="auto"></audio>
<audio id="a_up" src="up.mp3" preload="auto"></audio>
<audio id="a_down" src="down.mp3" preload="auto"></audio>
<audio id="a_touch" src="touch.mp3" preload="auto"></audio>
<audio id="a_touch2" src="touch2.mp3" preload="auto"></audio>
<audio id="audioWin" src="win.mp3" preload="auto"></audio>
<audio id="audioLost" src="lost.mp3" preload="auto"></audio>
<audio id="audioEndLost" src="endlost.mp3" preload="auto"></audio>
<audio id="audioEndHappy" src="endhappy.mp3" preload="auto"></audio>

<script>
// ภาษาและการตอบสนองแบบสุภาพสั้น ๆ (สำหรับ screen reader เท่านั้น)
const sr = document.getElementById('sr');
function announce(text){ sr.textContent = text; }

// Mapping gestures -> audio element id
const GESTURES = ['left','right','up','down','touch','touch2'];
const AUDIO_MAP = {
  left: document.getElementById('a_left'),
  right: document.getElementById('a_right'),
  up: document.getElementById('a_up'),
  down: document.getElementById('a_down'),
  touch: document.getElementById('a_touch'),
  touch2: document.getElementById('a_touch2')
};

// UI elements
const startBtn = document.getElementById('startBtn');
const audioStart = document.getElementById('audioStart');
const audioBackground = document.getElementById('audioBackground');
const audioWin = document.getElementById('audioWin');
const audioLost = document.getElementById('audioLost');
const audioEndLost = document.getElementById('audioEndLost');
const audioEndHappy = document.getElementById('audioEndHappy');
const gameArea = document.getElementById('gameArea');

// Game state
let playing = false;
let waitingForTwoFingerStart = false;
let currentRound = 0;
let mistakes = 0;
const MAX_MISTAKES = 3;
let sequence = [];
let playerIndex = 0;
let roundTimer = null;
let roundTimeoutMs = 2000; // will be set per-round
let maxGesturesToWin = 10; // user requested ending at 10 gestures

// helper to compute required gestures for a given round
function gesturesForRound(roundNumber){
  // groups of 3 rounds increment gestures by 1, starting at 1
  const group = Math.ceil(roundNumber/3);
  return group; // so rounds 28-30 correspond to 10 gestures
}

// helper to compute time limit per round (ms)
function timeForRound(roundNumber){
  const g = gesturesForRound(roundNumber);
  // According to the specification mapping:
  // 1-3 => 2s, 4-6 => 2s, 7-9 => 2.5, 10-12 => 3s, 13-15 => 3.5, 16-18 => 4s, then continue +0.5s each group
  // We'll implement this formulaically: base for group 1-2 = 2000ms, group3=2500ms, group4=3000ms, etc.
  const groupIndex = g; // as defined
  let seconds;
  if(groupIndex <= 2) seconds = 2.0;
  else seconds = 2.0 + 0.5*(groupIndex-2);
  return Math.round(seconds*1000);
}

// Random sequence generator
function generateSequence(n){
  const arr = [];
  for(let i=0;i<n;i++) arr.push(GESTURES[Math.floor(Math.random()*GESTURES.length)]);
  return arr;
}

// Play coach audio sequence for the round (sequentially)
function playCoachSequence(seq){
  return new Promise(resolve=>{
    let i=0;
    function playNext(){
      if(i>=seq.length) return resolve();
      const g = seq[i];
      const audio = AUDIO_MAP[g];
      if(!audio) { i++; return playNext(); }
      // ensure restart from 0
      audio.currentTime = 0;
      audio.play().catch(()=>{});
      // when ended, small gap then next
      audio.onended = ()=>{
        audio.onended = null;
        i++;
        // small 200ms gap before next prompt to avoid overlap
        setTimeout(playNext,200);
      };
    }
    // start
    playNext();
  });
}

// Play background loop when started
function startBackground(){
  audioBackground.currentTime = 0;
  audioBackground.play().catch(()=>{});
}
function stopBackground(){
  try{ audioBackground.pause(); audioBackground.currentTime = 0;}catch(e){}
}

// Start a round
async function startRound(){
  currentRound++;
  playerIndex = 0;
  const needed = gesturesForRound(currentRound);
  announce('รอบที่ '+currentRound+' เรียก '+needed+' ท่าทาง');
  sequence = generateSequence(needed);
  // delay 3s only for the very first round after 2-finger start
  let preDelay = (currentRound===1) ? 3000 : 0;
  await new Promise(r=>setTimeout(r, preDelay));
  // play coach prompts
  await playCoachSequence(sequence);
  // after coach finishes, start timer for player input
  roundTimeoutMs = timeForRound(currentRound);
  // start a timer; if time runs out => treated as lost for that round
  let timeoutFired = false;
  roundTimer = setTimeout(()=>{
    timeoutFired = true;
    handleRoundFailure('time');
  }, roundTimeoutMs);
  // announce for screen reader
  announce('ทำตามท่าทางที่ได้ยินภายใน '+(roundTimeoutMs/1000)+' วินาที');
}

// Handle correct completion of a round
async function handleRoundSuccess(){
  clearTimeout(roundTimer);
  audioWin.currentTime = 0;
  await audioWin.play().catch(()=>{});
  // wait for audio to finish
  await new Promise(r=>{ audioWin.onended = ()=>{ audioWin.onended=null; r(); }; });
  // 1s delay before next round
  await new Promise(r=>setTimeout(r,1000));
  // check for win condition: if gesture count (sequence length) >= maxGesturesToWin -> final win
  if(sequence.length >= maxGesturesToWin){
    // player wins game
    playing = false;
    stopBackground();
    audioEndHappy.currentTime = 0;
    await audioEndHappy.play().catch(()=>{});
    announce('คุณชนะ! จบเกม');
    // done
  } else {
    // continue to next round
    startRound();
  }
}

// Handle round failure (wrong gesture or timeout)
async function handleRoundFailure(reason){
  clearTimeout(roundTimer);
  mistakes++;
  audioLost.currentTime = 0;
  await audioLost.play().catch(()=>{});
  // wait for lost audio to finish
  await new Promise(r=>{ audioLost.onended = ()=>{ audioLost.onended=null; r(); }; });
  // if mistakes >= MAX => game over
  if(mistakes >= MAX_MISTAKES){
    stopBackground();
    audioEndLost.currentTime = 0;
    await audioEndLost.play().catch(()=>{});
    announce('แพ้แล้ว จบเกม');
    playing = false;
    return;
  }
  // otherwise 1s delay then next round (same roundNumber +1)
  await new Promise(r=>setTimeout(r,1000));
  startRound();
}

// Gesture recognition on the big gameArea
let touchState = {
  startX:0,startY:0,startTime:0,startTouches:0,
  lastTapTime:0,lastTapX:0,lastTapY:0
};

function resetTouchState(){ touchState = {startX:0,startY:0,startTime:0,startTouches:0,lastTapTime:0,lastTapX:0,lastTapY:0}; }

// Interpret a detected gesture string from user's action and compare to expected
function onDetectedGesture(gesture){
  if(!playing) return;
  // check sequence
  const expected = sequence[playerIndex];
  // allow performing gestures earlier/later but in order
  if(gesture === expected){
    playerIndex++;
    // if completed all in this round
    if(playerIndex >= sequence.length){
      handleRoundSuccess();
    }
    // else wait for next gesture until timer
  } else {
    // wrong -> fail round immediately
    handleRoundFailure('wrong');
  }
}

// Touch handlers
gameArea.addEventListener('touchstart', e=>{
  if(e.touches && e.touches.length>0){
    touchState.startTouches = e.touches.length;
    touchState.startX = e.touches[0].clientX;
    touchState.startY = e.touches[0].clientY;
    touchState.startTime = Date.now();
  }
}, {passive:true});

gameArea.addEventListener('touchend', e=>{
  const dt = Date.now() - (touchState.startTime || Date.now());
  const movedY = (touchState.startY || 0) - ( (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientY : touchState.startY);
  const movedX = ((e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientX : touchState.startX) - touchState.startX;
  const absX = Math.abs(movedX);
  const absY = Math.abs(movedY);

  // Two-finger swipe up detection (for starting game when waiting)
  if(touchState.startTouches>=2 && movedY > 50){
    if(waitingForTwoFingerStart){
      // start playing background and begin first round
      waitingForTwoFingerStart = false;
      playing = true;
      startBackground();
      announce('เริ่มเกม');
      // small delay 0 then startRound which itself delays 3s for round1
      setTimeout(()=>startRound(), 0);
    }
    resetTouchState();
    return;
  }

  // Single-finger taps/swipes
  // detect swipe thresholds
  const SWIPE_THRESHOLD = 40; // px
  if(absX > absY && absX > SWIPE_THRESHOLD){
    // horizontal swipe
    const dir = movedX > 0 ? 'right' : 'left';
    AUDIO_MAP[dir].currentTime = 0; AUDIO_MAP[dir].play().catch(()=>{});
    onDetectedGesture(dir);
    resetTouchState();
    return;
  }
  if(absY > absX && absY > SWIPE_THRESHOLD){
    // vertical swipe (note movedY positive means upward, as we computed startY - endY)
    const dir = movedY > 0 ? 'up' : 'down';
    AUDIO_MAP[dir].currentTime = 0; AUDIO_MAP[dir].play().catch(()=>{});
    onDetectedGesture(dir);
    resetTouchState();
    return;
  }

  // If no significant move -> treat as tap or double tap
  const now = Date.now();
  const lastTapDelta = now - (touchState.lastTapTime || 0);
  const TAP_MAX_DELAY = 350; // ms for double tap
  const currentX = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientX : 0;
  const currentY = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientY : 0;
  if(lastTapDelta <= TAP_MAX_DELAY && Math.hypot(currentX - touchState.lastTapX, currentY - touchState.lastTapY) < 30){
    // double tap
    touchState.lastTapTime = 0;
    AUDIO_MAP['touch2'].currentTime = 0; AUDIO_MAP['touch2'].play().catch(()=>{});
    onDetectedGesture('touch2');
  } else {
    // single tap
    touchState.lastTapTime = now;
    touchState.lastTapX = currentX; touchState.lastTapY = currentY;
    // set a short timeout to confirm single tap (so double-tap can be detected)
    setTimeout(()=>{
      if(Date.now() - touchState.lastTapTime >= TAP_MAX_DELAY){
        // it's a single tap
        AUDIO_MAP['touch'].currentTime = 0; AUDIO_MAP['touch'].play().catch(()=>{});
        onDetectedGesture('touch');
        touchState.lastTapTime = 0;
      }
    }, TAP_MAX_DELAY+10);
  }

}, {passive:true});

// Start button flow: play start.mp3, on ended show gameArea and wait for two-finger swipe up
startBtn.addEventListener('click', ()=>{
  // play start audio
  audioStart.currentTime = 0;
  audioStart.play().catch(()=>{});
  announce('กำลังเล่นเสียงเริ่มต้น');
  audioStart.onended = ()=>{
    audioStart.onended = null;
    // make game area active and wait for 2-finger swipe up
    document.getElementById('container').style.display = 'none';
    gameArea.style.display = 'block';
    waitingForTwoFingerStart = true;
    announce('ปัดขึ้นด้วยสองนิ้วเพื่อเริ่มเกม');
  };
});

// Allow reseting/starting a new game by two-finger swipe up even when not in waiting state (after game ended)
// We'll listen globally on gameArea for two-finger swipe up when not playing
// The logic in touchend already checks waitingForTwoFingerStart flag

// If the user wants to start a new game after game over using two-finger swipe up
// When not playing and not waiting, we set waitingForTwoFingerStart=true when detecting a two-finger swipe
// To allow that, expose a small keyboard shortcut for desktop testing: Ctrl+Alt+I to simulate two-finger swipe start
window.addEventListener('keydown', (e)=>{
  if(e.ctrlKey && e.altKey && e.key.toLowerCase()==='i'){
    if(!playing){
      waitingForTwoFingerStart = false;
      playing = true;
      mistakes = 0; currentRound = 0;
      startBackground();
      announce('เริ่มเกมใหม่');
      setTimeout(()=>startRound(),0);
    }
  }
});

// When game ends (playing=false) user can start again by two-finger swipe up inside gameArea
// To support that: when playing===false and user performs two-finger swipe (we already check waitingForTwoFingerStart),
// so set waitingForTwoFingerStart true when gameArea is visible and game not playing
// We'll add a small focus handler to enable waiting state

gameArea.addEventListener('touchstart', (e)=>{
  if(!playing && gameArea.style.display!=='none'){
    // if two touches present right away, treat as start
    if(e.touches && e.touches.length>=2){
      waitingForTwoFingerStart = true;
    }
  }
}, {passive:true});

// reset while pausing/unloading
window.addEventListener('pagehide', ()=>{ stopBackground(); });

// initial announcement
announce('พร้อมแล้ว กดปุ่มเริ่มเพื่อเริ่มต้น');

</script>
</body>
</html>
