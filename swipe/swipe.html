<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Swipe (accessible)</title>
<style>
  /* Minimal, mostly invisible UI -- game is audio driven for blind users */
  html,body{height:100%;margin:0;background:#111;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans Thai UI",sans-serif}
  #gameArea{height:100vh;display:flex;align-items:center;justify-content:center}
  button{font-size:1.25rem;padding:16px 24px;border-radius:12px;border:none}
  .visually-hidden{position:absolute!important;height:1px;width:1px;overflow:hidden;clip:rect(1px,1px,1px,1px);white-space:nowrap}
</style>
</head>
<body>
<div id="gameArea" role="application" aria-label="Swipe game area">
  <!-- Visible start button only for activation. After start, UI remains minimal. -->
  <button id="startBtn" aria-label="เริ่มเกม">เริ่ม</button>
</div>
<!-- Live region to communicate state to screen readers (kept minimal) -->
<div id="live" class="visually-hidden" aria-live="assertive"></div>

<script>
/*
  Swipe game (audio-first, touch-gesture driven).
  - Plays start.mp3 when user presses Start (asks to turn off screen reader).
  - Waits for two-finger swipe up to begin the actual game.
  - On two-finger swipe up: plays background.mp3 loop and begins rounds.
  - Gesture mapping (beta1): left,right,up,down,touch,double-touch mapped to audio files.
  - Rounds progression: blocks of 3 rounds; gestures per round increases by 1 every 3 rounds.
    (1 gesture: rounds 1-3, 2 gestures: 4-6, ... continues until 10 gestures -> player wins)
  - Timing per round: as specified in the request.
  - Player has max 3 mistakes (on 3rd mistake player loses).
  - Plays win.mp3 on successful round, lost.mp3 on failure. After those play and 1s pause, next round begins.

  NOTES / LIMITATIONS:
  - Browsers do NOT provide a reliable API to know whether a screen reader is on or off. Therefore this code cannot truly "detect" VoiceOver state.
    As a practical check, the game asks player to turn off the screen reader via start.mp3 and will only progress when the user performs the required two-finger swipe up. This acts as the user's confirmation.
  - On mobile platforms some system gestures may still intercept touches; we attempt to preventDefault touchmove to reduce interference but cannot guarantee full suppression of system gestures.
*/

// Configuration
const SFX = {
  start: 'start.mp3',
  background: 'background.mp3',
  left: 'left.mp3',
  right: 'right.mp3',
  up: 'up.mp3',
  down: 'down.mp3',
  touch: 'touch.mp3',
  touch2: 'touch2.mp3',
  win: 'win.mp3',
  lost: 'lost.mp3',
  endlost: 'endlost.mp3',
  endhappy: 'endhappy.mp3'
};

const gestureNames = ['left','right','up','down','touch','touch2'];

// Round timing rules specified
function gesturesForRound(round){
  // pattern: each block of 3 rounds increments gestures by 1, starting with 1 at rounds 1-3
  // gestures = 1 + floor((round-1)/3)
  return 1 + Math.floor((round-1)/3);
}

function timeForRound(round){
  // mapping from user's spec for rounds 1..18; then continue pattern: increase time slightly as gestures increase.
  if(round<=3) return 2000;
  if(round<=6) return 2000;
  if(round<=9) return 2500;
  if(round<=12) return 3000;
  if(round<=15) return 3500;
  if(round<=18) return 4000;
  // continue incremental progression beyond 18 up to 10 gestures
  const base = 4000; // for 6 gestures
  const extraBlocks = Math.floor((gesturesForRound(round)-6));
  return base + Math.max(0,extraBlocks) * 500; // each extra gesture block +0.5s
}

// Game state
let round = 0;
let mistakes = 0;
const maxMistakes = 3;
let inRound = false;
let requiredSequence = [];
let backgroundAudio = null;
let playingBackground = false;
let awaitingStartSwipe = false;
let gameActive = false;

const startBtn = document.getElementById('startBtn');
const live = document.getElementById('live');
const gameArea = document.getElementById('gameArea');

function announce(text){
  // announce to SR (but user asked no visible text; still provide announcement for accessibility)
  live.textContent = text;
}

function audio(src, loop=false){
  const a = new Audio(src);
  a.preload = 'auto';
  a.loop = !!loop;
  a.onplay = ()=>{};
  return a;
}

function preloadAll(){
  for(const k in SFX){
    const a = new Audio(SFX[k]);
    a.preload = 'auto';
  }
}
preloadAll();

// Prevent default gestures on gameArea as much as possible
['touchstart','touchmove','touchend','pointerdown','pointermove','pointerup'].forEach(ev=>{
  gameArea.addEventListener(ev, e=>{
    // only when game has been started we try to prevent defaults to keep custom gestures.
    if(gameActive){
      try{ e.preventDefault(); }catch(_){ }
    }
  }, {passive:false});
});

// Utility: random sequence of N gestures
function randomSequence(n){
  const seq = [];
  for(let i=0;i<n;i++){
    const idx = Math.floor(Math.random()*gestureNames.length);
    seq.push(gestureNames[idx]);
  }
  return seq;
}

// Gesture detection (single-finger taps/double taps and swipes, plus two-finger swipe up to start)
let pointerData = {active:false, startX:0, startY:0, startTime:0, taps:0, lastTapTime:0};
let multiTouchStart = null;

function detectSwipe(startX,startY,endX,endY){
  const dx = endX-startX, dy = endY-startY;
  if(Math.abs(dx) > Math.abs(dy)){
    return dx>0 ? 'right' : 'left';
  }else{
    return dy>0 ? 'down' : 'up';
  }
}

// We'll listen to touch events for gestures
let touchStartInfo = null;

gameArea.addEventListener('touchstart', e=>{
  if(e.touches.length===2){
    // record two finger start for the special 'start game' gesture
    multiTouchStart = [
      {x:e.touches[0].clientX,y:e.touches[0].clientY},
      {x:e.touches[1].clientX,y:e.touches[1].clientY}
    ];
  }
  if(e.touches.length===1){
    const t = e.touches[0];
    touchStartInfo = {x:t.clientX,y:t.clientY,time:Date.now()};
  }
}, {passive:false});

gameArea.addEventListener('touchend', e=>{
  // If there was a two-finger touch and now ended -> detect two-finger swipe up
  if(multiTouchStart && (!e.touches || e.touches.length===0)){
    // Some platforms report changedTouches; use changedTouches
    const changed = e.changedTouches ? e.changedTouches : [];
    // find avg end positions from changed or last known positions
    if(changed.length>=2){
      const avgStartY = (multiTouchStart[0].y + multiTouchStart[1].y)/2;
      const avgEndY = (changed[0].clientY + changed[1].clientY)/2;
      const deltaY = avgEndY - avgStartY;
      if(deltaY < -30){ // upward
        // two-finger swipe up detected
        onTwoFingerSwipeUp();
      }
    }else{
      // if we can't reliably get changed touches, still attempt to start if any upward movement
      onTwoFingerSwipeUp();
    }
    multiTouchStart = null;
  }

  if(touchStartInfo){
    const t = e.changedTouches && e.changedTouches[0];
    const end = t ? {x:t.clientX,y:t.clientY} : touchStartInfo;
    const dt = Date.now() - touchStartInfo.time;
    const dx = end.x - touchStartInfo.x, dy = end.y - touchStartInfo.y;
    const dist = Math.hypot(dx,dy);
    if(dist < 12 && dt < 400){
      // tap
      handleGesture('touch');
      // detect double tap: naive approach using timestamp
      const now = Date.now();
      if(now - pointerData.lastTapTime < 400){
        // double tap registered
        handleGesture('touch2');
      }
      pointerData.lastTapTime = now;
    }else if(dist >= 12){
      const g = detectSwipe(touchStartInfo.x,touchStartInfo.y,end.x,end.y);
      handleGesture(g);
    }
  }

  touchStartInfo = null;
}, {passive:false});

// For mouse / desktop testing we can also support click & key events (optional)

document.addEventListener('keydown', e=>{
  // allow starting/restarting with arrow keys (for testing or keyboard users)
  if(e.key === 'ArrowUp' && (e.ctrlKey && e.altKey)){
    // ctrl+alt+up as an alternate two-finger swipe for testing
    onTwoFingerSwipeUp();
  }
});

// Core handlers
function onTwoFingerSwipeUp(){
  if(!awaitingStartSwipe) return;
  // this acts as the "confirmation" that player turned off screen reader
  awaitingStartSwipe = false;
  startBackground();
  setTimeout(()=>{
    startNewGame();
  }, 3000); // requested 3s delay before first round after start gesture
}

function startBackground(){
  if(backgroundAudio){ backgroundAudio.pause(); backgroundAudio=null; }
  backgroundAudio = audio(SFX.background, true);
  backgroundAudio.loop = true;
  backgroundAudio.play().catch(()=>{});
  playingBackground = true;
}
function stopBackground(){
  if(backgroundAudio){ backgroundAudio.pause(); backgroundAudio.currentTime=0; backgroundAudio=null; }
  playingBackground = false;
}

function playSFX(name){
  if(!SFX[name]) return Promise.resolve();
  return new Promise(resolve=>{
    const a = audio(SFX[name], false);
    a.onended = ()=>resolve();
    a.onerror = ()=>resolve();
    a.play().catch(()=>resolve());
  });
}

async function startNewGame(){
  round = 1;
  mistakes = 0;
  gameActive = true;
  announce('เริ่มเกม รอบที่ 1');
  await runRound();
}

async function runRound(){
  if(!gameActive) return;
  if(mistakes >= maxMistakes){
    await handleLoss();
    return;
  }
  const gcount = gesturesForRound(round);
  // win condition: if gcount >=10 -> completing this round finishes the whole game
  const timeLimit = timeForRound(round);
  requiredSequence = randomSequence(gcount);
  inRound = true;
  announce(`รอบ ${round} มี ${gcount} ท่าทาง`);

  // Play each gesture audio in sequence with a small gap (so the player hears the coach for each gesture)
  for(let i=0;i<requiredSequence.length;i++){
    const name = requiredSequence[i];
    await playSFX(name);
    // slight short gap between commands to avoid overlap
    await new Promise(r=>setTimeout(r,200));
  }

  // Now wait for player input for the whole sequence within the timeLimit
  const startTime = Date.now();
  let idx = 0;
  let timedOut = false;

  announce('ฟังแล้วทำตามท่าทาง ทีละท่าภายในเวลาที่กำหนด');

  // temporary storage of inputs
  const inputs = [];

  // create a listener that captures gestures and checks sequence
  function onInputGesture(g){
    if(!inRound) return;
    inputs.push(g);
    // For taps we might receive both touch and touch2 if double-detected; we treat each as separate expected token
    // Check correctness progressively
    if(g !== requiredSequence[idx]){
      // wrong
      inRound = false;
      mistakes += 1;
      playSFX('lost').then(async ()=>{
        // after lost and 1s delay
        await new Promise(r=>setTimeout(r,1000));
        // if mistakes reached max -> end
        if(mistakes >= maxMistakes){
          await handleLoss();
        }else{
          round += 1;
          await runRound();
        }
      });
      // remove temporary listener
      document.removeEventListener('gamegesture', gestureEventHandler);
      return;
    }
    idx++;
    if(idx >= requiredSequence.length){
      // cleared round
      inRound = false;
      document.removeEventListener('gamegesture', gestureEventHandler);
      playSFX('win').then(async ()=>{
        await new Promise(r=>setTimeout(r,1000));
        // if this round had >=10 gestures -> full win
        if(requiredSequence.length >= 10){
          await handleFullWin();
        }else{
          round += 1;
          await runRound();
        }
      });
    }
  }

  // wrapper to dispatch custom event
  function gestureEventHandler(e){ onInputGesture(e.detail); }
  document.addEventListener('gamegesture', gestureEventHandler);

  // time monitoring loop
  while(inRound){
    if(Date.now() - startTime > timeLimit){
      timedOut = true; break;
    }
    // small tick
    await new Promise(r=>setTimeout(r,100));
  }

  if(timedOut){
    inRound = false;
    document.removeEventListener('gamegesture', gestureEventHandler);
    mistakes += 1;
    await playSFX('lost');
    await new Promise(r=>setTimeout(r,1000));
    if(mistakes >= maxMistakes){
      await handleLoss();
    }else{
      round += 1;
      await runRound();
    }
  }
}

async function handleLoss(){
  gameActive = false;
  stopBackground();
  announce('แพ้ เล่นไม่ผ่านจำนวนครั้งที่กำหนด');
  await playSFX('lost');
  await playSFX('endlost');
  // Now game waits for two-finger swipe up to restart
  awaitingStartSwipe = true;
}

async function handleFullWin(){
  gameActive = false;
  stopBackground();
  announce('ชนะ เล่นจนครบท่าทางที่กำหนด');
  await playSFX('win');
  await playSFX('endhappy');
  awaitingStartSwipe = true;
}

// External gesture handler that maps detected gestures into 'gamegesture' events
function handleGesture(g){
  // Accept only our known gestures
  if(!gestureNames.includes(g)) return;
  // If awaiting start swipe, ignore gestures except two-finger swipe which triggers onTwoFingerSwipeUp
  if(awaitingStartSwipe) return;
  // If background isn't playing yet, gestures shouldn't trigger game input (except the special start)
  if(!gameActive) return;
  // Dispatch custom event
  const ev = new CustomEvent('gamegesture', {detail: g});
  document.dispatchEvent(ev);
}

// Start button behavior
startBtn.addEventListener('click', async ()=>{
  // Play start audio asking user to turn off screen reader and that two-finger swipe up will begin the game
  startBtn.disabled = true;
  announce('กำลังเล่นเสียงเริ่ม กรุณาปิดตัวอ่านหน้าจอ แล้วทำการปัดสองนิ้วขึ้นเพื่อเริ่มเกม');
  await playSFX('start');
  // After start.mp3 finishes, we mark that we are awaiting the special two-finger swipe up
  awaitingStartSwipe = true;
  // keep the background stopped until two-finger swipe
});

// Map low-level detections to handleGesture wrapper
function mapAndHandle(g){
  // g might be 'touch' or 'touch2' or swipes
  handleGesture(g);
}

// Expose handleGesture to the rest of code (used by touchend logic above)
window.handleGesture = (g)=>{
  mapAndHandle(g);
};

// Our internal handleGesture function called by touchend detection
function handleGesture(g){
  // If we are currently in awaitingStartSwipe and g is 'up' from a two-finger check, it's handled in onTwoFingerSwipeUp
  // Here we map single gestures into input
  // For double tap we used 'touch2' earlier; but ensure not to treat single tap twice
  const ev = new CustomEvent('gamegesture', {detail:g});
  document.dispatchEvent(ev);
}

// For safety: expose a restart API using two-finger swipe up when game inactive
// (already handled by onTwoFingerSwipeUp which checks awaitingStartSwipe)

// Friendly hint for non-touch testing: reveal instructions in console
console.log('Swipe game loaded. Use Start button. On touch devices: two-finger swipe up to begin.');
</script>
</body>
</html>
