<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sound Jewels</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700;800&display=swap');

/* Global Styles */
body {
    font-family: 'Sarabun', sans-serif;
    background-color: #0d1a26;
    color: #e0f2fe;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    text-align: center;
    user-select: none;
    touch-manipulation: none;
}
.container {
    background-color: #1a2a3a;
    border: 4px solid #4a5c6c;
    border-radius: 1.5rem;
    padding: 2rem 1.5rem; 
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
    max-width: 95%;
    width: 600px;
    position: relative;
}
.game-title {
    font-size: clamp(2rem, 5vw, 3rem);
    font-weight: 800;
    color: #93c5fd; 
    text-shadow: 3px 3px 6px rgba(0,0,0,0.3);
    margin-bottom: 1rem;
}
.info-panel {
    font-size: 1.125rem;
    margin-bottom: 1rem;
    color: #94a3b8;
    padding: 0.5rem;
    border-radius: 0.5rem;
    background-color: #2a3a4a;
}

/* Button Styles */
.game-button {
    background-color: #10b981; 
    color: white;
    padding: 1rem 2rem;
    font-size: 1.25rem;
    font-weight: bold;
    border: none;
    border-radius: 9999px;
    cursor: pointer;
    transition: background-color 0.3s, transform 0.1s;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    margin: 0.5rem;
}
.game-button:hover {
    background-color: #059669;
    transform: translateY(-2px);
}
.game-button:active {
    transform: scale(0.95);
}
.game-button.secondary {
    background-color: #f97316; 
}
.game-button.secondary:hover {
    background-color: #ea580c;
}
.game-button.mode {
    width: 100%;
    margin: 0.5rem 0;
}
.game-button.back-menu {
    position: absolute;
    top: 1rem;
    left: 1rem;
    padding: 0.5rem 1rem;
    font-size: 1rem;
    background-color: #3b82f6;
}
.game-button.back-menu:hover {
    background-color: #2563eb;
}

/* Game Board Styles */
#game-board-container {
    margin: 1rem auto;
    display: flex;
    justify-content: center;
    align-items: center;
}

#game-board {
    display: grid;
    border: 5px solid #6366f1; 
    border-radius: 0.5rem;
    box-shadow: 0 0 15px rgba(99, 102, 241, 0.5);
    background-color: #2a3a4a;
    max-width: 100%;
    aspect-ratio: 1 / 1;
}

.gem {
    aspect-ratio: 1 / 1;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: clamp(0.8rem, 3vw, 1.5rem);
    font-weight: bold;
    color: black;
    border: 1px solid rgba(0,0,0,0.1);
    cursor: pointer;
    transition: transform 0.1s, box-shadow 0.1s;
    position: relative;
    user-select: none;
    outline: none;
}

/* Gem Colors (Thai Names) */
.gem-แดง { background-color: #ef4444; } 
.gem-เขียว { background-color: #10b981; } 
.gem-น้ำเงิน { background-color: #3b82f6; } 
.gem-เหลือง { background-color: #facc15; } 
.gem-ม่วง { background-color: #a855f7; } 
.gem-ชมพู { background-color: #ec4899; } 
.gem-ฟ้า { background-color: #06b6d4; } 

/* Focus & Selected States */
.focused {
    border: 3px solid #fde047; 
    box-shadow: 0 0 10px #fde047;
    transform: scale(1.05);
    z-index: 10;
}
.selected {
    border: 3px solid #ff0000; 
    box-shadow: 0 0 15px #ff0000;
    animation: pulse 0.5s infinite alternate;
    z-index: 11;
}

@keyframes pulse {
    from { box-shadow: 0 0 15px #ff0000; }
    to { box-shadow: 0 0 20px #ff0000, 0 0 5px rgba(255, 0, 0, 0.8); }
}

/* Game Stats */
#game-stats {
    display: flex;
    justify-content: space-around;
    margin-bottom: 1rem;
    background-color: #0f172a;
    padding: 0.75rem;
    border-radius: 0.75rem;
    flex-wrap: wrap; /* ให้แสดงผลได้ดีบนมือถือ */
}
.stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-weight: bold;
    line-height: 1.2;
    padding: 0.25rem 0.5rem;
}
.stat-label {
    font-size: 0.875rem;
    color: #94a3b8;
}
.stat-value {
    font-size: 1.5rem;
    color: #38bdf8;
}
#target-value {
    color: #fde047;
}
#timer-value {
    color: #fca5a5; 
}
</style>
</head>
<body>

<div class="container">
<!-- Back to Main Menu Button -->
<button class="game-button back-menu" onclick="window.location.href = '../index.html';">กลับเมนูหลัก</button>

<!-- Main Menu UI -->
<div id="main-menu-ui">
    <h1 class="game-title">Sound Jewels</h1>
    <p class="info-panel">
        ยินดีต้อนรับ! พิชิต 10 ด่านเพื่อเป็นสุดยอดนักเรียงเพชร! ด่านสูงขึ้น เวลาลดลง
        <br>กดลูกศรขึ้น ลง ซ้าย ขวา เพื่อเลื่อนตำแหน่ง enter หรือ space เพื่อกดเลือกและกดสลับ ในระหว่างเกมเริ่ม
        <br>เลือกโหมดสำหรับเล่นได้ทันที
    </p>
    <button class="game-button mode" onclick="startLevelMode(5)">5 x 5</button>
    <button class="game-button mode secondary" onclick="startLevelMode(6)">6 x 6</button>
    <div id="loading-status" class="mt-4 text-yellow-400 hidden">
        กำลังโหลดไฟล์เสียง... โปรดรอสักครู่
    </div>
</div>

<!-- Game UI -->
<!-- role="application" คือหัวใจสำคัญในการดักจับท่าทางสัมผัส VoiceOver (ปัด 1 นิ้ว จะถูกแปลงเป็น Arrow Keys) -->
<div id="game-ui" class="hidden">
    <div id="game-stats">
        <div class="stat-item">
            <span class="stat-label">ด่านที่</span>
            <span id="level-value" class="stat-value">1</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">เป้าหมาย</span>
            <span id="target-value" class="stat-value text-yellow-400">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">คะแนนรวม</span>
            <span id="total-score-value" class="stat-value">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">คะแนนด่านนี้</span>
            <span id="score-value" class="stat-value">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">เวลา</span>
            <span id="timer-value" class="stat-value">60</span>
        </div>
    </div>

    <!-- Game Board will be injected here -->
    <div id="game-board-container">
        <div id="game-board" role="grid"></div>
    </div>

    <p id="key-controls" class="info-panel text-sm mt-4 p-2">
        ควบคุม: (↑ ↓ ← →) = ย้าย | (Enter / Space) = เลือก / สลับ
    </p>
</div>

<!-- Level/Game Summary UI -->
<div id="summary-ui" class="hidden">
    <!-- heading ผลคะแนนที่ต้องการให้ focus ชี้ไปทันที -->
    <h1 id="summary-heading" class="text-3xl font-extrabold text-red-400 mb-4" tabindex="-1"></h1>
    <p id="summary-info" class="info-panel text-2xl font-bold">จะลองอีกรอบหรือจะเปลี่ยนโหมด เลือกได้เลย?</p>

    <div id="summary-buttons" class="flex flex-wrap justify-center mt-6 mb-0"> <!-- เพิ่ม mb-0 เพื่อลบบรรทัดว่างใต้ปุ่ม -->
        <!-- ปุ่มนี้จะถูกใช้เพื่อแสดงการหน่วงเวลาและจะซ่อนไป -->
        <button class="game-button" id="next-level-button" onclick="loadNextLevel()" style="display:none;">ด่านต่อไปกำลังจะเริ่ม</button>
        <!-- ปุ่มนี้จะแสดงเมื่อจบเกม (แพ้หรือชนะ) -->
        <button class="game-button" id="new-game-button" onclick="startLevelMode(boardSize)" style="display:none;">เล่นใหม่อีกครั้ง</button>
        <button class="game-button secondary" id="main-menu-button" onclick="showMainMenu()">กลับไปเลือกโหมดใหม่</button>
    </div>
</div>
	<!-- Live region สำหรับประกาศข้อความให้ screen reader -->
	<div id="live-region" aria-live="polite" class="sr-only absolute w-1 h-1 overflow-hidden"></div>
<script>
// Global variables
let boardSize = 0;
let board = [];
let score = 0; // Current score for the level
let totalScore = 0; // Total score across all levels
let currentLevel = 1;
let levelTargetScore = 200; // Updated dynamically
let timeLeft = 60;
const MAX_LEVEL = 10; // กำหนดจำนวนด่านสูงสุด
let gameTimer = null;
let selectedGem = null;
let focusedRow = 0;
let focusedCol = 0;
let isSwapping = false;
let isClearing = false;
let isGameReady = false;
let isPausedForAudio = false; // สถานะเพื่อรอไฟล์เสียง a6.mp3 เล่นจบ
let warningAudio = null; // เพื่อเก็บ instance ของเสียง timerWarning เพื่อหยุดได้
let endAudio = null; // เพื่อเก็บ instance ของเสียง end sounds (failEnd, levelCleared, gameWin)
let isTestMode = false; // Flag for test mode (skip cheat)
let keySequence = []; // For detecting 'skip' and 'time' sequences
let lastKeyTime = 0; // Timestamp for last key in sequence
let cheatUses = 0; // NEW: Counter for 'time' cheat uses per level

// Gem Data
const GEM_COLORS_THAI = ["แดง", "เขียว", "น้ำเงิน", "เหลือง", "ม่วง", "ชมพู", "ฟ้า"];

// Audio files map
const AUDIO_FILES = {
    'a1.mp3': 'select', 
    'a2.mp3': 'match',  // ใช้สำหรับแมทช์แรก
    'a3.mp3': 'fail',   // ใช้สำหรับ fail และ time cheat confirmation
    'a4.mp3': 'failEnd',     
    'a5.mp3': 'move',    // การเคลื่อนที่
    'a6.mp3': 'levelStart', // เริ่มเกม/ด่าน
    'a7.mp3': 'combo',   // คอมโบต่อเนื่อง
    'heart.mp3': 'timerWarning', // เสียงเตือนเมื่อเหลือ 10 วินาที
    'f.mp3': 'fail2',     // เสียงเมื่อสลับเพชรที่ไม่ติดกัน
    'new1.mp3': 'levelCleared', // เสียงผ่านด่าน (1-9)
    'new4.mp3': 'gameWin' // เสียงชนะเกมครบ 10 ด่าน
};
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const audioBuffers = {};

/**
 * Level Calculation Functions
 */
function calculateLevelTime(level) {
    // ด่าน 1: 60s, ด่าน 10: 30s. ลดลง 30s ใน 9 ช่วง
    const reductionPerInterval = 30 / (MAX_LEVEL - 1); 
    const time = 60 - (level - 1) * reductionPerInterval;
    // ปัดเป็นจำนวนเต็มที่ใกล้ที่สุด
    return Math.round(time); 
}

function calculateTargetScore(level) {
    // ฐาน: 200, เพิ่มขึ้นด่านละ 100
    return 200 + (level - 1) * 100;
}

function getColorCount(level) {
    // ปรับจำนวนสีเพื่อให้ด่านแรกๆ ง่ายขึ้น (สีน้อย = เรียงง่ายกว่า)
    if (level <= 1) return 3; // ด่าน 1: 3 สี
    if (level <= 4) return 4; // ด่าน 2-4: 4 สี
    if (level <= 7) return 5; // ด่าน 5-7: 5 สี
    if (level <= 9) return 6; // ด่าน 8-9: 6 สี
    return 7; // ด่าน 10: 7 สี
}

/**
 * Utility functions for Audio
 */
async function loadAudioFile(url, name) {
    try {
        // Assume audio files are in a standard 'audio/' directory
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const arrayBuffer = await response.arrayBuffer();
        audioBuffers[name] = await audioContext.decodeAudioData(arrayBuffer);
    } catch (error) {
        console.error(`Error loading audio file ${url}:`, error);
        // Fallback to HTML Audio if decoding fails
        const audio = new Audio(url);
        audio.preload = 'auto';
        audioBuffers[name] = audio;
    }
}

async function loadAllAudio() {
    const loadingStatus = document.getElementById('loading-status');
    loadingStatus.classList.remove('hidden');

    const loadPromises = Object.entries(AUDIO_FILES).map(([filename, name]) =>
        loadAudioFile(`audio/${filename}`, name) 
    );

    await Promise.all(loadPromises);

    loadingStatus.textContent = 'โหลดไฟล์เสียงเสร็จสมบูรณ์! พร้อมเริ่มเกม';
    setTimeout(() => loadingStatus.classList.add('hidden'), 1000);
}

function playSound(name) {
    const buffer = audioBuffers[name];
    if (!buffer) {
        console.warn(`Audio buffer '${name}' not found. Cannot play sound.`);
        return;
    }

    let instance;
    if (buffer instanceof Audio) {
        // Fallback HTML Audio
        buffer.currentTime = 0;
        buffer.play().catch(e => console.error(`Error playing fallback audio ${name}:`, e));
        instance = buffer;
    } else {
        // Web Audio API
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.connect(audioContext.destination);
        source.start(0);
        instance = source;
    }

    // ถ้าเป็น timerWarning เก็บ instance เพื่อหยุดได้
    if (name === 'timerWarning') {
        warningAudio = instance;
    }

    // ถ้าเป็น end sounds เก็บ instance เพื่อหยุดได้
    if (['failEnd', 'levelCleared', 'gameWin'].includes(name)) {
        endAudio = instance;
    }

    return instance;
}

// ฟังก์ชันหยุดเสียง timerWarning
function stopWarningSound() {
    if (warningAudio) {
        if (warningAudio instanceof Audio) {
            // HTML Audio
            warningAudio.pause();
            warningAudio.currentTime = 0;
        } else {
            // Web Audio Source
            warningAudio.stop();
        }
        warningAudio = null;
    }
}

// ฟังก์ชันหยุดเสียง end sounds (failEnd, levelCleared, gameWin)
function stopEndAudio() {
    if (endAudio) {
        if (endAudio instanceof Audio) {
            // HTML Audio
            endAudio.pause();
            endAudio.currentTime = 0;
        } else {
            // Web Audio Source
            endAudio.stop();
        }
        endAudio = null;
    }
}

/**
 * ฟังก์ชันเล่นเสียงและรอจนกว่าเสียงจะเล่นจบ (สำหรับ a6.mp3)
 * @param {string} name - ชื่อไฟล์เสียงที่ต้องการเล่น ('levelStart')
 * @returns {Promise<void>} - Resolve เมื่อเสียงเล่นจบ
 */
async function playAudioAndAwait(name) {
    const buffer = audioBuffers[name];
    if (!buffer) {
        console.warn(`Audio buffer '${name}' not found. No delay applied.`);
        return;
    }

    if (buffer instanceof Audio) {
        // Fallback HTML Audio
        buffer.currentTime = 0;
        return new Promise(resolve => {
            const onEnded = () => {
                buffer.removeEventListener('ended', onEnded);
                resolve();
            };
            // NOTE: Add a timeout to resolve in case the 'ended' event is missed
            const timeoutId = setTimeout(resolve, 3000); 

            buffer.addEventListener('ended', onEnded);
            buffer.play().catch(e => {
                console.error("Error playing fallback audio, resolving immediately:", e);
                clearTimeout(timeoutId);
                resolve();
            });
        });
    }

    // Web Audio API
    const source = audioContext.createBufferSource();
    source.buffer = buffer;
    source.connect(audioContext.destination);
    
    return new Promise(resolve => {
        source.onended = resolve;
        source.start(0);
    });
}

/**
 * UI and Game Flow
 */
function showMainMenu() {
    // Clear timer when returning to main menu
    if (gameTimer) clearInterval(gameTimer);
    stopWarningSound(); // หยุดเสียงเตือนถ้ามี
    stopEndAudio(); // หยุด end sounds ถ้ามี
    document.getElementById('main-menu-ui').classList.remove('hidden');
    document.getElementById('game-ui').classList.add('hidden');
    document.getElementById('summary-ui').classList.add('hidden');
    isGameReady = false;
    isPausedForAudio = false; // Ensure unpaused
    cheatUses = 0; // NEW: Reset cheat uses
    // VoiceOver/NVDA returns to normal browse mode
    deactivateApplicationMode();
}

/**
 * ฟังก์ชันสำหรับตั้งค่าโฟกัสไปที่ heading ของหน้าสรุปผล เพื่อการเข้าถึง (Accessibility)
 */
function focusSummaryHeading() {
    const summaryHeading = document.getElementById('summary-heading');
    summaryHeading.setAttribute('tabindex', '-1'); 
    summaryHeading.focus();
    speakAnnouncement(summaryHeading.textContent); 
}

function speakAnnouncement(text) {
    const announcementEl = document.getElementById('live-region');
    if (announcementEl) {
        announcementEl.textContent = text;
        setTimeout(() => {
            announcementEl.textContent = '';
        }, 1000);
	}
}

// --- Focus Mode Activation (VoiceOver Application Mode) ---
function activateApplicationMode() {
    const gameUI = document.getElementById('game-ui');
    gameUI.setAttribute('role', 'application'); 
    gameUI.setAttribute('tabindex', '0');
    setTimeout(() => {
        try {
            gameUI.focus();
        } catch (e) {
            console.error("Could not set focus on game UI:", e);
        }
    }, 100);

    // ให้ทุก gem มี tabindex="0" เพื่อรองรับ VoiceOver หรือ keyboard
    document.querySelectorAll('.gem').forEach(gem => {
        gem.setAttribute('tabindex', '0');
    });
}

function deactivateApplicationMode() {
    const gameUI = document.getElementById('game-ui');
    gameUI.removeAttribute('role');
    gameUI.removeAttribute('tabindex');
    gameUI.removeAttribute('aria-activedescendant'); 
    // ไม่ลบ tabindex จาก .gem เพื่อให้ทั้ง iOS และ Windows เล่นได้
}

async function startLevelMode(size) {
    stopEndAudio(); // หยุด end sounds ก่อนเริ่มใหม่
    boardSize = size;
    totalScore = 0; // Reset total score for a new game
    currentLevel = 1; // Start at Level 1
    isTestMode = false; // Reset test mode
    cheatUses = 0; // NEW: Reset cheat uses
    // Load the first level
    await loadNextLevel(true); 
}

async function loadNextLevel(isNewGame = false) {
    if (gameTimer) clearInterval(gameTimer);

    stopEndAudio(); // หยุด end sounds ก่อนโหลดด่านใหม่

    score = 0; // Reset score for the new level
    levelTargetScore = calculateTargetScore(currentLevel);
    timeLeft = calculateLevelTime(currentLevel);
    if (isTestMode) {
        timeLeft *= 10; // x10 time for test mode
    }
    cheatUses = 0; // NEW: Reset cheat uses for new level

    isSwapping = false;
    isClearing = false;
    selectedGem = null;
    focusedRow = 0;
    focusedCol = 0;
    isPausedForAudio = true; // PAUSE INPUT เพื่อรอเสียง a6.mp3 เล่นจบ

    document.getElementById('main-menu-ui').classList.add('hidden');
    document.getElementById('summary-ui').classList.add('hidden');
    document.getElementById('game-ui').classList.remove('hidden');

    updateStats();

    if (!isGameReady) {
        await loadAllAudio();
        isGameReady = true;
    }

    setupBoard(boardSize);
    renderBoard();
    activateApplicationMode();
    setFocus(0, 0); 
    
    await playAudioAndAwait('levelStart'); 
    
    isPausedForAudio = false; // UNPAUSE INPUT
    startGameTimer();

    if (!isNewGame) {
        const levelAnnouncement = `ด่านที่ ${currentLevel} เริ่มแล้ว! เป้าหมายคะแนน: ${levelTargetScore} คะแนน เวลา: ${timeLeft} วินาที`;
        speakAnnouncement(levelAnnouncement);
    }
}

/**
 * Game Board Setup & Rendering
 */
function checkMatchAt(r, c, currentBoard, isSetup = false) {
    if (!isSetup) return false;
    const color = currentBoard[r][c];
    if (!color) return false;

    if (c >= 2 && currentBoard[r][c - 1] === color && currentBoard[r][c - 2] === color) {
        return true;
    }

    if (r >= 2 && currentBoard[r - 1][c] === color && currentBoard[r - 2][c] === color) {
        return true;
    }

    return false;
}

function setupBoard(size) {
    const colorCount = getColorCount(currentLevel);
    const availableColors = GEM_COLORS_THAI.slice(0, colorCount);
    board = Array(size).fill(0).map(() => Array(size).fill(0));

    for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
            let newColor;
            do {
                newColor = availableColors[Math.floor(Math.random() * availableColors.length)];
                board[r][c] = newColor;
            } while (checkMatchAt(r, c, board, true));
        }
    }
}

function renderBoard() {
    const boardElement = document.getElementById('game-board');
    boardElement.innerHTML = '';
    boardElement.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;
    boardElement.style.width = boardElement.style.height = `min(90vw, 500px)`;

    for (let r = 0; r < boardSize; r++) {
        for (let c = 0; c < boardSize; c++) {
            const gem = document.createElement('div');
            gem.id = `gem-${r}-${c}`;
            gem.classList.add('gem', `gem-${board[r][c]}`);
            gem.setAttribute('aria-label', `${board[r][c]} แถว ${r + 1} คอลั่ม ${c + 1}`);
            gem.setAttribute('tabindex', '0');

            // focus event เพื่อ sync JS state
            gem.addEventListener('focus', () => {
                focusedRow = r;
                focusedCol = c;
                setFocus(r, c);
            });

            // click event เพื่อสลับ/เลือกเมื่อแตะ
            gem.addEventListener('click', () => {
                handleSelect(r, c);
            });

            boardElement.appendChild(gem);
        }
    }
}

function updateStats() {
    document.getElementById('level-value').textContent = currentLevel;
    document.getElementById('target-value').textContent = levelTargetScore;
    document.getElementById('total-score-value').textContent = totalScore + score; // Show running total
    document.getElementById('score-value').textContent = score; // Current level score
    document.getElementById('timer-value').textContent = timeLeft;
    
    const targetElement = document.getElementById('target-value');
    if (score / levelTargetScore > 0.75) {
        targetElement.classList.add('text-red-400');
        targetElement.classList.remove('text-yellow-400');
    } else {
        targetElement.classList.remove('text-red-400');
        targetElement.classList.add('text-yellow-400');
    }
}

function startGameTimer() {
    let hasPlayedWarning = false; // Track if warning sound has played
    gameTimer = setInterval(() => {
        if (timeLeft > 0) {
            timeLeft--;
            if (timeLeft > 10) {
                hasPlayedWarning = false;
            }
            if (timeLeft === 10 && !hasPlayedWarning) {
                playSound('timerWarning');
                hasPlayedWarning = true;
            }
            updateStats();
        } else {
            clearInterval(gameTimer);
            gameOver(false); 
        }
    }, 1000);
}

/**
 * ฟังก์ชันจบเกม (แพ้หมดเวลา หรือ ชนะด่านสุดท้าย)
 * @param {boolean} isWin - true ถ้าชนะด่านสุดท้าย, false ถ้าระยะเวลาหมด
 */
function gameOver(isWin = false) {
    if (gameTimer) clearInterval(gameTimer);
    stopWarningSound(); // หยุดเสียงเตือน
    
    if (isWin) {
        playSound('gameWin'); // new4.mp3 สำหรับชนะเกม
    } else {
        playSound('failEnd'); // a4.mp3 สำหรับแพ้ (หมดเวลา)
    }
    
    const finalTotalScore = totalScore + score;
    
    deactivateApplicationMode();
    isPausedForAudio = false; // Ensure unpaused

    document.getElementById('game-ui').classList.add('hidden');
    document.getElementById('summary-ui').classList.remove('hidden');
    
    document.getElementById('next-level-button').style.display = 'none'; 
    document.getElementById('new-game-button').style.display = 'inline-block';
    document.getElementById('main-menu-button').style.display = 'inline-block';

    const summaryHeading = document.getElementById('summary-heading');
    summaryHeading.classList.remove('text-red-400', 'text-green-400'); 

    document.getElementById('summary-info').textContent = 'จะลองอีกรอบหรือจะเปลี่ยนโหมด เลือกได้เลย?';

    if (isWin) {
        summaryHeading.textContent = `ยินดีด้วย คุณพิชิตเกมได้แล้ว! คะแนนรวมของคุณคือ ${finalTotalScore} คะแนน`;
        summaryHeading.classList.add('text-green-400');
    } else {
        summaryHeading.textContent = `จอดแค่ด่าน ${currentLevel} ลองฝีมือกันใหม่ได้นะ? คะแนนรวม: ${finalTotalScore} คะแนน`;
        summaryHeading.classList.add('text-red-400');
    }
}

/**
 * ฟังก์ชันผ่านด่าน (ระดับ 1 ถึง 9)
 */
function levelCleared() {
    if (gameTimer) clearInterval(gameTimer);
    stopWarningSound(); // หยุดเสียงเตือน
    
    totalScore += score;
    const currentLevelScore = score;
    const finalTotalScore = totalScore;
    
    deactivateApplicationMode();
    isPausedForAudio = false; // Ensure unpaused

    document.getElementById('game-ui').classList.add('hidden');
    document.getElementById('summary-ui').classList.remove('hidden');
    document.getElementById('next-level-button').style.display = 'none'; 
    document.getElementById('new-game-button').style.display = 'none';
    document.getElementById('main-menu-button').style.display = 'none'; 

    const summaryHeading = document.getElementById('summary-heading');
    summaryHeading.classList.remove('text-red-400', 'text-green-400');

    if (currentLevel < MAX_LEVEL) {
        playSound('levelCleared'); // เล่น new1.mp3 สำหรับผ่านด่าน 1-9
        
        const nextLevel = currentLevel + 1;
        
        let headingText;

        if (currentLevel === 1) {
            headingText = `ด่านที่ ${currentLevel} ผ่านแล้ว! คุณได้ ${currentLevelScore} คะแนน เตรียมตัวไปด่านต่อไป!`;
        } else {
            headingText = `ด่านที่ ${currentLevel} ผ่านแล้ว! คุณได้ ${currentLevelScore} คะแนน (รวม ${finalTotalScore} คะแนน) เตรียมตัวไปด่านต่อไป!`;
        }
        
        summaryHeading.textContent = headingText;
        summaryHeading.classList.add('text-green-400');

        document.getElementById('summary-info').textContent = 'พร้อมลุยด่านต่อไปกัน!';
        
        const nextLevelButton = document.getElementById('next-level-button');
        nextLevelButton.textContent = `ด่านที่ ${nextLevel} กำลังจะเริ่ม`;

        currentLevel++; // Increment level for next load
        
        let countdown = 3;
        const countdownInterval = setInterval(() => {
            countdown--;
            nextLevelButton.textContent = `ด่านที่ ${currentLevel} กำลังจะเริ่มใน ${countdown}...`;
            if (countdown <= 0) {
                clearInterval(countdownInterval);
                loadNextLevel();
            }
        }, 1000);

    } else {
        gameOver(true);
    }
}

/**
 * Focus and Selection Logic
 */
function setFocus(r, c) {
    focusedRow = Math.max(0, Math.min(r, boardSize - 1));
    focusedCol = Math.max(0, Math.min(c, boardSize - 1));
    const newGemId = `gem-${focusedRow}-${focusedCol}`;

    // Remove visual focus จากทุก gem
    document.querySelectorAll('.gem').forEach(gem => {
        gem.classList.remove('focused');
    });

    const newGem = document.getElementById(newGemId);
    if (newGem) {
        newGem.classList.add('focused');
        document.getElementById('game-ui').setAttribute('aria-activedescendant', newGemId);

        // ให้โฟกัสไปที่ gem จริง ถ้าไม่ได้มาจาก keyboard
        if (document.activeElement !== newGem) {
            newGem.focus();
        }
    }
}

function handleSelect(r, c) {
    if (isSwapping || isClearing || isPausedForAudio) return;

    const currentGem = { r, c };
    const gemElement = document.getElementById(`gem-${r}-${c}`);

    if (!selectedGem) {
        selectedGem = currentGem;
        gemElement.classList.add('selected');
        playSound('select'); 
    } else if (selectedGem.r === r && selectedGem.c === c) {
        gemElement.classList.remove('selected');
        selectedGem = null;
    } else if (isAdjacent(selectedGem, currentGem)) {
        attemptSwap(selectedGem, currentGem);
    } else {
        document.getElementById(`gem-${selectedGem.r}-${selectedGem.c}`).classList.remove('selected');
        selectedGem = null;
        playSound('fail2'); // Play f.mp3 for non-adjacent selection
    }
}

function isAdjacent(gem1, gem2) {
    return (
        Math.abs(gem1.r - gem2.r) + Math.abs(gem1.c - gem2.c) === 1
    );
}

/**
 * Game Logic (Swap, Match, Gravity)
 */
async function attemptSwap(gem1, gem2) {
    isSwapping = true;
    if (selectedGem) {
        document.getElementById(`gem-${selectedGem.r}-${selectedGem.c}`).classList.remove('selected');
        selectedGem = null;
    }

    await visualSwap(gem1, gem2);
    swapGems(gem1, gem2);

    const matchedGems = findMatches(board);

    if (matchedGems.length > 0) {
        await handleClearing(matchedGems);
    } else {
        playSound('fail');
        await visualSwap(gem1, gem2, true); 
        swapGems(gem1, gem2); 
    }

    isSwapping = false;
}

function swapGems(gem1, gem2) {
    const temp = board[gem1.r][gem1.c];
    board[gem1.r][gem1.c] = board[gem2.r][gem2.c];
    board[gem2.r][gem2.c] = temp;
}

async function visualSwap(gem1, gem2, swapBack = false) {
    const gemElement1 = document.getElementById(`gem-${gem1.r}-${gem1.c}`);
    const gemElement2 = document.getElementById(`gem-${gem2.r}-${gem2.c}`);

    if (gemElement1 && gemElement2) {
        const color1 = board[gem1.r][gem1.c];
        const color2 = board[gem2.r][gem2.c];
        const targetColor1 = swapBack ? color2 : color1;
        const targetColor2 = swapBack ? color1 : color2;

        gemElement1.classList.remove(`gem-${color1}`);
        gemElement1.classList.add(`gem-${targetColor2}`);
        gemElement1.setAttribute('aria-label', `${targetColor2} แถว ${gem1.r + 1} คอลั่ม ${gem1.c + 1}`);

        gemElement2.classList.remove(`gem-${color2}`);
        gemElement2.classList.add(`gem-${targetColor1}`);
        gemElement2.setAttribute('aria-label', `${targetColor1} แถว ${gem2.r + 1} คอลั่ม ${gem2.c + 1}`);
    }

    return new Promise(resolve => setTimeout(resolve, swapBack ? 200 : 100));
}

function findMatches(currentBoard) {
    const matches = new Set();
    const size = currentBoard.length;

    for (let r = 0; r < size; r++) {
        for (let c = 0; c <= size - 3; c++) {
            const color = currentBoard[r][c];
            if (color && color === currentBoard[r][c + 1] && color === currentBoard[r][c + 2]) {
                let startC = c;
                while(startC < size && currentBoard[r][startC] === color) {
                    matches.add(`${r},${startC}`);
                    startC++;
                }
                c = startC - 1; 
            }
        }
    }

    for (let c = 0; c < size; c++) {
        for (let r = 0; r <= size - 3; r++) {
            const color = currentBoard[r][c];
            if (color && color === currentBoard[r + 1][c] && color === currentBoard[r + 2][c]) {
                let startR = r;
                while(startR < size && currentBoard[startR][c] === color) {
                    matches.add(`${startR},${c}`);
                    startR++;
                }
                r = startR - 1;
            }
        }
    }

    return Array.from(matches).map(str => {
        const [r, c] = str.split(',').map(Number);
        return { r, c };
    });
}

async function handleClearing(initialMatches) {
    isClearing = true;
    let currentMatches = initialMatches;
    let newMatchesFound = false;
    let comboCount = 0;

    while (currentMatches.length > 0) {
        newMatchesFound = true;
        comboCount++;

        const matchCount = currentMatches.length;
        const scoreMultiplier = 15; 
        score += matchCount * scoreMultiplier * (isTestMode ? 10 : 1);

        timeLeft += 3 * (isTestMode ? 10 : 1); 
        if (timeLeft > 10) {
            stopWarningSound();
        }
        updateStats();
        
        if (comboCount === 1) {
            playSound('match');
        } else {
            playSound('combo');
        }

        for (const { r, c } of currentMatches) {
            board[r][c] = null;
            const gemEl = document.getElementById(`gem-${r}-${c}`);
            if (gemEl) {
                gemEl.classList.remove(...gemEl.classList);
                gemEl.classList.add('gem');
                gemEl.setAttribute('aria-label', `ช่องว่าง`);
                gemEl.removeAttribute('tabindex'); 
            }
        }

        await new Promise(resolve => setTimeout(resolve, 300)); 

        applyGravity();
        fillNewGems();
        renderBoard();
        setFocus(focusedRow, focusedCol); 
        currentMatches = findMatches(board);
    }

    isClearing = false;
    if (newMatchesFound && score >= levelTargetScore) {
        levelCleared();
    }
}

function applyGravity() {
    const size = boardSize;
    for (let c = 0; c < size; c++) {
        let writeRow = size - 1;
        for (let r = size - 1; r >= 0; r--) {
            if (board[r][c] !== null) {
                if (r !== writeRow) {
                    board[writeRow][c] = board[r][c];
                    board[r][c] = null;
                }
                writeRow--;
            }
        }
    }
}

function fillNewGems() {
    const size = boardSize;
    const colorCount = getColorCount(currentLevel);
    const availableColors = GEM_COLORS_THAI.slice(0, colorCount);

    for (let c = 0; c < size; c++) {
        for (let r = 0; r < size; r++) {
            if (board[r][c] === null) {
                board[r][c] = availableColors[Math.floor(Math.random() * availableColors.length)];
            }
        }
    }
}

/**
 * Keyboard Controls (Drives both physical keyboard and VoiceOver Swipes)
 */
document.addEventListener('keydown', (e) => {
    if (document.getElementById('game-ui').classList.contains('hidden') || isSwapping || isClearing || isPausedForAudio) {
        return;
    }

    let newR = focusedRow;
    let newC = focusedCol;
    let isMovementKey = false;

    switch (e.key) {
        case 'ArrowUp':
            e.preventDefault();
            newR = focusedRow - 1;
            isMovementKey = true;
            break;
        case 'ArrowDown':
            e.preventDefault();
            newR = focusedRow + 1;
            isMovementKey = true;
            break;
        case 'ArrowLeft':
            e.preventDefault();
            newC = focusedCol - 1;
            isMovementKey = true;
            break;
        case 'ArrowRight':
            e.preventDefault();
            newC = focusedCol + 1;
            isMovementKey = true;
            break;
        case 'Enter':
        case ' ':
            e.preventDefault();
            handleSelect(focusedRow, focusedCol);
            return; 
        default:
            if (!document.getElementById('game-ui').classList.contains('hidden')) {
                const now = Date.now();
                if (now - lastKeyTime > 2000) {
                    keySequence = [];
                }
                keySequence.push(e.key.toLowerCase());
                lastKeyTime = now;

                // Check for 'skip' cheat
                if (keySequence.join('') === 'skip') {
                    keySequence = [];
                    if (gameTimer) clearInterval(gameTimer);
                    currentLevel = 10;
                    isTestMode = true;
                    loadNextLevel();
                }
                // NEW: Check for 'time' cheat
                else if (keySequence.join('') === 'time') {
                    keySequence = [];
                    if (cheatUses < 2) {
                        cheatUses++;
                        timeLeft += 90;
                        playSound('fail'); // Play a3.mp3 as confirmation
                        updateStats();
                        if (timeLeft > 10) {
                            stopWarningSound();
                        }
                        speakAnnouncement('เพิ่มเวลา 90 วินาที!');
                    }
                }
            }
            return;
    }

    if (newR >= 0 && newR < boardSize && newC >= 0 && newC < boardSize) {
        if (isMovementKey && (newR !== focusedRow || newC !== focusedCol)) {
            playSound('move');
        }
        setFocus(newR, newC);
    }
});

// Initialize: Load audio files first and show main menu
window.onload = () => {
    showMainMenu();
};
</script>
</body>
</html>